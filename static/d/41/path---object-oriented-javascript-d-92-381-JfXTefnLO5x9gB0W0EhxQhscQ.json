{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog","author":"Kyle Mathews"}},"markdownRemark":{"id":"be73cef2-f41f-56f5-be7a-1d86600f1175","excerpt":"面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特性（属性）与动作（方法）。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放到一个对象里。   1. javascript 当中的 prototype 在js…","html":"<p>面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特性（属性）与动作（方法）。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放到一个对象里。  </p>\n<h3>1. javascript 当中的 prototype</h3>\n<p>在js当中，constructor属性是专门为function而设计的，她存在于<strong>每一个function</strong>的<strong>prototype属性中</strong>。constructor保存了指向function的一个引用。同时，实例化（new 操作符）的book的<strong>proto</strong> 属性是函数prototype的一个内部引用 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Book = function(id,bookname,price) {\n    this.id = id;\n    this.bookname = bookname;\n    this.price = price;\n}\n\nBook.prototype.display = function(){\n        console.log(this.bookname);\n    }\n\nvar book = new Book(10,&#39;javascript &#39;,55);\n\nconsole.log(book.__proto__.constructor === Book) //true\nconsole.log(Book.prototype.constructor === Book) //true\nconsole.log(Book.prototype.isPrototypeOf(book))  //true</code></pre></div>\n<p>在上面的代码当中，如果写成</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Book.prototype = {\n    display: function(){\n        cosole.log(&#39;display&#39;);       \n    }\n}\n\nconsole.log(Book.prototype.constructor === Book) //false</code></pre></div>\n<p>因为constructor被覆盖掉了，针对这种情况，可以按照这种方式去写：  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Book.prototype = {\n    constructor:Book,\n    display: function(){\n        cosole.log(&#39;display&#39;);       \n    }\n}\n\nconsole.log(Book.prototype.constructor === Book) //true</code></pre></div>\n<h3>2. 验证prototype属性</h3>\n<p><code class=\"language-text\">isPrototypeOf()</code> 这个方法用来判断某个prototype对象与某个实例的关系</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(Book.prototype.isPrototypeOf(book)) //true</code></pre></div>\n<p><code class=\"language-text\">hasOwnProperty()</code> 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype的属性。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">book.hasOwnProperty(&#39;id&#39;); //true\nbook.hasOwnProperty(&#39;display&#39;); //false</code></pre></div>\n<p>in 运算符 可以用来判断某个实例是否含有某个属性，不管是不是本地属性。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(&#39;id&#39; in book); //true\nconsole.log(&#39;display&#39; in book) //true</code></pre></div>\n<p>in 运算符还可以用来遍历某个对象的所有属性</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var prop in book){\n    console.log(&quot;book[&quot;+ prop +&quot;]=&quot;+book[prop]);\n}\n/**\nbook[id]=10\nbook[bookname]=javascript \nbook[price]=55\nbook[display]=function (){\n    console.log(this.bookname);\n}\n**/</code></pre></div>\n<h3>3. 闭包实现一个完整的类</h3>\n<p>有时候我们经常将类的静态变量通过闭包来实现</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Book = (function(){\n    //静态私有变量\n    var bookNum = 0;\n    //静态私有方法\n    function checkBook(name){\n        console.log(name);\n    }\n    //创建类\n    function _book(newId,newName,newPrice){\n        // 私有变量\n        var name,price;\n        function checkID(id){}\n        //特权方法\n        this.getName = function(){}\n        this.getPrice = function(){}\n        this.setName = function(){}\n        this.setPrice = function(){}\n        //公有属性\n        this.id = newId;\n        //公有方法\n        this.copy = function(){}\n        bookNum ++;\n        if(bookNum &gt; 100){\n            throw new Error(&#39;我们仅出版100本书&#39;);\n        }\n        this.setName(name);\n        this.setPrice(price);\n    }\n    \n    _book.prototype = {\n        isJSbook :false,\n        display: function(){}\n    }\n    \n    return _book;\n})();</code></pre></div>\n<p>闭包有权访问另外一个函数作用域中的变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可以访问到类函数作用域中的变量（booknum，checkBook）。<br>\n同时在闭包内部实现了原型属性和方法，最终得以返回一个完整的类。</p>","frontmatter":{"title":"javascript 面向对象编程（封装）","date":"May 22, 2016"}}},"pageContext":{"slug":"/object-oriented-javascript/","previous":{"fields":{"slug":"/nginx-spa-app-config/"},"frontmatter":{"title":"nginx部署前端SPA应用实践"}},"next":null}}