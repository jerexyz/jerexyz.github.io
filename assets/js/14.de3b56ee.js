(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{347:function(o,t,n){"use strict";n.r(t);var e=n(0),s=Object(e.a)({},(function(){var o=this,t=o.$createElement,n=o._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[n("p",[o._v("面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特性（属性）与动作（方法）。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放到一个对象里。")]),o._v(" "),n("h3",{attrs:{id:"_1-javascript-当中的-prototype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript-当中的-prototype"}},[o._v("#")]),o._v(" 1. javascript 当中的 prototype")]),o._v(" "),n("p",[o._v("在 js 当中，constructor 属性是专门为 function 而设计的，她存在于"),n("strong",[o._v("每一个 function")]),o._v("的"),n("strong",[o._v("prototype 属性中")]),o._v("。constructor 保存了指向 function 的一个引用。同时，实例化（new 操作符）的 book 的"),n("strong",[o._v("proto")]),o._v(" 属性是函数 prototype 的一个内部引用")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("var Book = function(id,bookname,price) {\n    this.id = id;\n    this.bookname = bookname;\n    this.price = price;\n}\n\nBook.prototype.display = function(){\n        console.log(this.bookname);\n    }\n\nvar book = new Book(10,'javascript ',55);\n\nconsole.log(book.__proto__.constructor === Book) //true\nconsole.log(Book.prototype.constructor === Book) //true\nconsole.log(Book.prototype.isPrototypeOf(book))  //true\n")])])]),n("p",[o._v("在上面的代码当中，如果写成")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("Book.prototype = {\n    display: function(){\n        cosole.log('display');\n    }\n}\n\nconsole.log(Book.prototype.constructor === Book) //false\n")])])]),n("p",[o._v("因为 constructor 被覆盖掉了，针对这种情况，可以按照这种方式去写：")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("Book.prototype = {\n    constructor:Book,\n    display: function(){\n        cosole.log('display');\n    }\n}\n\nconsole.log(Book.prototype.constructor === Book) //true\n")])])]),n("h3",{attrs:{id:"_2-验证-prototype-属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-验证-prototype-属性"}},[o._v("#")]),o._v(" 2. 验证 prototype 属性")]),o._v(" "),n("p",[n("code",[o._v("isPrototypeOf()")]),o._v(" 这个方法用来判断某个 prototype 对象与某个实例的关系")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("console.log(Book.prototype.isPrototypeOf(book)) //true\n")])])]),n("p",[n("code",[o._v("hasOwnProperty()")]),o._v(" 每个实例对象都有一个 hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自 prototype 的属性。")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("book.hasOwnProperty('id'); //true\nbook.hasOwnProperty('display'); //false\n")])])]),n("p",[o._v("in 运算符 可以用来判断某个实例是否含有某个属性，不管是不是本地属性。")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("console.log('id' in book); //true\nconsole.log('display' in book) //true\n")])])]),n("p",[o._v("in 运算符还可以用来遍历某个对象的所有属性")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v('for(var prop in book){\n    console.log("book["+ prop +"]="+book[prop]);\n}\n/**\nbook[id]=10\nbook[bookname]=javascript\nbook[price]=55\nbook[display]=function (){\n    console.log(this.bookname);\n}\n**/\n')])])]),n("h3",{attrs:{id:"_3-闭包实现一个完整的类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-闭包实现一个完整的类"}},[o._v("#")]),o._v(" 3. 闭包实现一个完整的类")]),o._v(" "),n("p",[o._v("有时候我们经常将类的静态变量通过闭包来实现")]),o._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[o._v("var Book = (function(){\n    //静态私有变量\n    var bookNum = 0;\n    //静态私有方法\n    function checkBook(name){\n        console.log(name);\n    }\n    //创建类\n    function _book(newId,newName,newPrice){\n        // 私有变量\n        var name,price;\n        function checkID(id){}\n        //特权方法\n        this.getName = function(){}\n        this.getPrice = function(){}\n        this.setName = function(){}\n        this.setPrice = function(){}\n        //公有属性\n        this.id = newId;\n        //公有方法\n        this.copy = function(){}\n        bookNum ++;\n        if(bookNum > 100){\n            throw new Error('我们仅出版100本书');\n        }\n        this.setName(name);\n        this.setPrice(price);\n    }\n\n    _book.prototype = {\n        isJSbook :false,\n        display: function(){}\n    }\n\n    return _book;\n})();\n")])])]),n("p",[o._v("闭包有权访问另外一个函数作用域中的变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可以访问到类函数作用域中的变量（booknum，checkBook）。"),n("br"),o._v("\n同时在闭包内部实现了原型属性和方法，最终得以返回一个完整的类。")])])}),[],!1,null,null,null);t.default=s.exports}}]);